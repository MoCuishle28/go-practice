Defer:
	1.defer 语句预设一个函数调用(即推迟函数调用)，被defer的函数 会在正在执行函数返回前被调用。
	2.被defer的函数的参数，在被defer时就会求值 而不是等到被调用时才求职(比如参数是另一个函数调用的返回值...)。
	3.被defer函数遵循 后进先出(LIFO)顺序。

	ex: learn-defer.go


new分配：
	Go有两种分配原语：	1.new 	2.make

	new:
		new 是个用来分配内存的内建函数，但它不会初始化内存，只会将内存置零。
		即：new(T) 会为类型为 T 的新项分配已置零的内存空间，并返回它的地址
		也就是一个类型为 *T 的值。
		用Go的术语来说，它返回一个指针，该指针指向新分配的，类型为 T 的零值。


复合字面：
	类似于类的构造函数，在创建类时初始化。

	ex： return &File{fd: fd, name: name} 		{} 内以 字段:值 的形式标出，未给出的字段则是零值
	Go 可以通过函数返回一个局部变量的地址，这点与C不同。
	该局部变量对应的数据 在函数返回后依然有效。
	实际上，每当获取一个 复合字面 的地址时，都将为一个新的实例分配内存

	表达式 new(File) 和 &File{} 是等价的

	复合字面同样可用于创建数组、切片以及映射


make分配：
	内建函数 make(T, args) 的目的不同于 new(T)。
	它只用于创建 切片、映射和信道，并返回类型为 T（而非 *T）的一个已初始化（而非置零）的值。 

	这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。
	例如： 切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量，在这三项被初始化之前，该切片为 nil。

	ex：make([]int, 10, 100)
	会分配一个具有100个 int 的数组空间，接着创建一个长度为10，容量为100并指向该数组中前10个元素的切片结构。
	与此相反，new([]int) 会返回一个指向新分配的，已置零的切片结构， 即一个指向 nil 切片值的指针。

	ex: learn-make_and_new.go

	Note：make 只适用于 映射、切片和信道 且不返回指针。若要获得明确的指针，使用 new 分配内存。


数组：
	1.数组是值。将一个数组赋予另一个数组会复制其所有元素。
	2.特别地，若将某个数组传入某个函数，它将接收到该数组的一份副本而非指针。
	3.数组的大小是其类型的一部分。类型 [10]int 和 [20]int 是不同的。

	若想传参效率高些，可以把参数设为指针。
	ex：
		func Sum(a *[3]float64) (sum float64) {
			for _, v := range *a {
				sum += v
			}
			return
		}

		array := [...]float64{7.0, 8.5, 9.1}
		x := Sum(&array)  // 注意显式的取址操作

	ex：learn-arr.go


切片：
	切片是对数组类型的封装，主要有三个成员：
		1.对数组元素的引用
		2.自身容量 (即切片可以获得的最大长度，若超过容量将会重新分配切片)
		3.数组长度 (切片所引用的数组的长度，append超出长度后 会分配新的数组给该切片)

	若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见，这可以理解为传递了底层数组的指针

	ex：learn-slice.go

	cap(), len() 应用于 nil 切片时会返回 0


二维切片：
	需要先 make 一个切片的切片 再用循环逐行分配
	ex： learn-slice.go 后面


映射：
	映射是引用类型，若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。

	关于映射的键：
		其键可以是任何相等性操作符支持的类型
		如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。
		切片不能用作映射键，因为它们的相等性还未定义。

	若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。

	ex：learn-map.go

	“逗号 ok”惯用法。在下面的例子中，若 tz 存在， seconds 就会被赋予适当的值，且 ok 会被置为true；
	若不存在，seconds 则会被置为零，而 ok 会被置为 false。
	ex：
		var timeZone = map[string]int{ "UTC":  0*60*60 }
		var seconds int
		var ok bool
		seconds, ok = timeZone[tz]

		func offset(tz string) int {
			if seconds, ok := timeZone[tz]; ok {
				return seconds
			}
			log.Println("unknown time zone:", tz)
			return 0
		}

	若仅需判断映射中是否存在某项而不关心实际的值，可使用空白标识符 （_）来代替该值的一般变量。
	ex：
		_, present := timeZone[tz]

	要删除映射中的某项，可使用内建函数 delete，它以映射及要被删除的键为实参。
	即便对应的键不在该映射中，此操作也是安全的。
	ex：
		delete(timeZone, "PDT")


append：
	append(x, y) 两个切片时，后一个参数 y 需要加上 ... 
	ex： 
		x := []int{1,2,3}
		y := []int{4,5,6}
		x = append(x, y...)
	
	用切片的删除需要用 append
	ex：
		a = append(a[:3], a[4:]...)


方法：
	可以为任何已命名的类型（除了指针或接口）定义方法； 接收者可不必为结构体。
	无论是否为指针接收者，都可以修改了？
	ex： learn-method.go

	以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。（？？？）
	不过有个方便的例外：若该值是可寻址的，那么 GO 就会自动插入取址操作符来对付一般的通过值调用的指针方法。


接口：
	// TODO


为副作用而导入：
	空白赋值会将代码标识为工作正在进行中。
	有时导入某个包只是为了其副作用，而没有任何明确的使用。
	例如：
		在 net/http/pprof 包的 init 函数中记录了HTTP处理程序的调试信息。
		它有个可导出的 API 但大部分客户端只需要该处理程序的记录和通过Web叶访问数据。

	只为了其副作用来哦导入该包， 只需将包重命名为空白标识符
		ex： import _ "net/http/pprof"
	这种导入格式能明确表示该包是为其副作用而导入的，因为没有其它使用该包的可能：
		在此文件中，它没有名字。（若它有名字而我们没有使用，编译器就会拒绝该程序。）


并发

通过通信共享内存：
	不要通过共享内存来通信，而应通过通信来共享内存。


Go程：
	它是与其它Go程并发运行在同一地址空间的函数。
	它是轻量级的，所有消耗几乎就只有栈空间的分配。
	而且栈最开始是非常小的，所以它们很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。

	Go程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待I/O，那么其它的线程就会运行。

	在函数或方法前添加 go 关键字能够在新的Go程中调用它。当调用完成后， 该Go程也会安静地退出。
	ex：learn-goroutine.go


信道：
	信道与映射一样，也需要通过 make 来分配内存。
	若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲的或同步的信道。
	ex：
		ci := make(chan int)            // 整数类型的无缓冲信道
		cj := make(chan int, 0)         // 整数类型的无缓冲信道
		cs := make(chan *os.File, 100)  // 指向文件指针的带缓冲信道

	无缓冲信道在通信时会同步交换数据，它能确保（两个Go程的）计算处于确定状态。

	接收者在收到数据前会一直阻塞。
	若信道是不带缓冲的，那么在接收者收到值前，发送者会一直阻塞。
	若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞。
	若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。


一个Web服务器：
	ex： learn-go-webserver.go

	main 之前的代码应该比较容易理解。我们通过一个标志为服务器设置了默认端口。
	模板变量 templ 它构建的HTML模版将会被服务器执行并显示在页面中。

	main 函数解析了参数标志并使用我们讨论过的机制将 QR 函数绑定到服务器的根路径。
	然后调用 http.ListenAndServe 启动服务器；它将在服务器运行时处于阻塞状态。

	QR 仅接受包含表单数据的请求，并为表单值 s 中的数据执行模板。

	模板包 html/template 非常强大；该程序只是浅尝辄止。
	它通过在运行时将数据项中提取的元素（在这里是表单值）传给 templ.Execute 执行因而重写了HTML文本。
	在模板文本（templateStr）中，双大括号界定的文本表示模板的动作。 从 {{if .}} 到 {{end}}
	的代码段仅在当前数据项（这里是点 .）的值非空时才会执行。 也就是说，当字符串为空时，此部分模板段会被忽略。

	其中两段 {{.}} 表示要将数据显示在模板中（即将查询字符串显示在Web页面上）。
	HTML模板包将自动对文本进行转义，因此文本的显示是安全的。

	余下的模板字符串只是页面加载时将要显示的HTML。如果这段解释你无法理解，请参考文档获得更多有关模板包的解释
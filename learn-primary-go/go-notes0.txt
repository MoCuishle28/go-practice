Defer:
	1.defer 语句预设一个函数调用(即推迟函数调用)，被defer的函数 会在正在执行函数返回前被调用。
	2.被defer的函数的参数，在被defer时就会求值 而不是等到被调用时才求职(比如参数是另一个函数调用的返回值...)。
	3.被defer函数遵循 后进先出(LIFO)顺序。

	ex: learn-defer.go


new分配：
	Go有两种分配原语：	1.new 	2.make

	new:
		new 是个用来分配内存的内建函数，但它不会初始化内存，只会将内存置零。
		即：new(T) 会为类型为 T 的新项分配已置零的内存空间，并返回它的地址
		也就是一个类型为 *T 的值。
		用Go的术语来说，它返回一个指针，该指针指向新分配的，类型为 T 的零值。


复合字面：
	类似于类的构造函数，在创建类时初始化。

	ex： return &File{fd: fd, name: name} 		{} 内以 字段:值 的形式标出，未给出的字段则是零值
	Go 可以通过函数返回一个局部变量的地址，这点与C不同。
	该局部变量对应的数据 在函数返回后依然有效。
	实际上，每当获取一个 复合字面 的地址时，都将为一个新的实例分配内存

	表达式 new(File) 和 &File{} 是等价的

	复合字面同样可用于创建数组、切片以及映射


make分配：
	内建函数 make(T, args) 的目的不同于 new(T)。
	它只用于创建 切片、映射和信道，并返回类型为 T（而非 *T）的一个已初始化（而非置零）的值。 

	这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。
	例如： 切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量，在这三项被初始化之前，该切片为 nil。

	ex：make([]int, 10, 100)
	会分配一个具有100个 int 的数组空间，接着创建一个长度为10，容量为100并指向该数组中前10个元素的切片结构。
	与此相反，new([]int) 会返回一个指向新分配的，已置零的切片结构， 即一个指向 nil 切片值的指针。

	ex: learn-make_and_new.go

	Note：make 只适用于 映射、切片和信道 且不返回指针。若要获得明确的指针，使用 new 分配内存。


数组：
	1.数组是值。将一个数组赋予另一个数组会复制其所有元素。
	2.特别地，若将某个数组传入某个函数，它将接收到该数组的一份副本而非指针。
	3.数组的大小是其类型的一部分。类型 [10]int 和 [20]int 是不同的。

	若想传参效率高些，可以把参数设为指针。
	ex：
		func Sum(a *[3]float64) (sum float64) {
			for _, v := range *a {
				sum += v
			}
			return
		}

		array := [...]float64{7.0, 8.5, 9.1}
		x := Sum(&array)  // 注意显式的取址操作

	ex：learn-arr.go


切片：
	切片是对数组类型的封装，主要有三个成员：
		1.对数组元素的引用
		2.自身容量 (即切片可以获得的最大长度，若超过容量将会重新分配切片)
		3.数组长度 (切片所引用的数组的长度，append超出长度后 会分配新的数组给该切片)

	若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见，这可以理解为传递了底层数组的指针

	ex：learn-slice.go

	cap(), len() 应用于 nil 切片时会返回 0


二维切片：
	需要先 make 一个切片的切片 再用循环逐行分配
	ex： learn-slice.go 后面


映射：
	映射是引用类型，若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。

	关于映射的键：
		其键可以是任何相等性操作符支持的类型
		如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。
		切片不能用作映射键，因为它们的相等性还未定义。

	若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。

	ex：learn-map.go

	“逗号 ok”惯用法。在下面的例子中，若 tz 存在， seconds 就会被赋予适当的值，且 ok 会被置为true；
	若不存在，seconds 则会被置为零，而 ok 会被置为 false。
	ex：
		var timeZone = map[string]int{ "UTC":  0*60*60 }
		var seconds int
		var ok bool
		seconds, ok = timeZone[tz]

		func offset(tz string) int {
			if seconds, ok := timeZone[tz]; ok {
				return seconds
			}
			log.Println("unknown time zone:", tz)
			return 0
		}

	若仅需判断映射中是否存在某项而不关心实际的值，可使用空白标识符 （_）来代替该值的一般变量。
	ex：
		_, present := timeZone[tz]

	要删除映射中的某项，可使用内建函数 delete，它以映射及要被删除的键为实参。
	即便对应的键不在该映射中，此操作也是安全的。
	ex：
		delete(timeZone, "PDT")



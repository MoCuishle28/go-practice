package main


import(
	"time"
	"fmt"
	"runtime"
)

/*
线程属于抢占式的多任务处理，即：操作系统可以随时切换线程，线程内部语句执行到任何一个点都可能会被切换出去
	一次开的线程数有限, 一个线程的大概有2MB左右?
协程是非抢占式的多任务处理，属于编译器、解释器、虚拟机层面的并发 即：协程何时被切换有我们决定(但某些切换点由调度器决定)
	多个协程可以在一个或多个线程上运行
	一次可以开很多个协程 goroutine量级大概在2KB~4KB?

goroutine 可能 自动切换的点:
	1.I/O, select
	2.channel
	3.等待锁
	4.函数调用(有时)
	5.runtime.Gosched()
参考, 不保证切换, 也不保证其他地方不切换

产生多少个线程, 每个线程放多少个协程由调度器决定(一般根据cpu有几个核心决定, 4核心->一般不超过4个线程)


"子程序是协程的一个特例"
				---名人语录..


但是协程进行IO操作时会自动交出控制权而被切换出去（因为I/O操作有等待时间）

查看数据访问冲突
go run -race 文件名.go
*/


func main() {
	var a[10] int
	for i := 0; i < 10; i++ {
		// 若不把i作为参数传入, 会导致循环退出时i=10 而goroutine还在运行 从而导致数组越界
		go func(i int) {
			for{
				// fmt.Println("goroutine: ", i)	// 打印输出属于IO操作，会交出协程控制权

				a[i]++						// 非IO操作不会自动交出控制权 程序会一直在执行第一个协程的该语句
				// 该语句手动交出控制权 否则会一直执行第一个协程,而导致程序无法退出(main函数也是一个协程)
				runtime.Gosched()
			}
			
		} (i)
	}

	time.Sleep(time.Millisecond)
	fmt.Println(a)
}